\AgdaHide{
\begin{code}
module replaceMin where

open import Size
open import Data.Nat renaming (_⊔_ to max)
open import Data.Product
open import Data.Sum
open import Relation.Binary.PropositionalEquality
open ≡-Reasoning

infixl 30 _⊛_
infixr 30 _⇒_
infixr 50 _⊗_
\end{code}
}

\section{Delayed Computations}
As we have seen, the Haskell implementation cannot automatically be transferred to Agda, because the termination cannot be guaranteed.
For that reason, we introduce a mechanism, which allows delaying computations.
Beside that, the termination must take these delays into account.

Let us start with thinking about delaying computations.
Types do not have any dependence on time: all their inhabitants are always available.
To make them depend on time, we look at types indexed by some type of times.
We call them \emph{timed types}.

\subsection{Timed Types}
The main ingredient for timed types, is thus the indexing type.
The most straightforward option would be the natural, but we shall refrain to use them.
Instead, we use \AF{Size} for the indices.
Before explaining why, let us precisely define what timed types are.

\begin{code}
SizedSet = Size → Set
\end{code}

In the remainder of this section, we explain how to use timed types.
For that we introduce several combinators: some of them to construct such types, some of them for actual programming.
The simplest lifts operations on types to timed types.

\begin{code}
_⇒_ : SizedSet → SizedSet → SizedSet
(A ⇒ B) i = A i → B i

_⊗_ : SizedSet → SizedSet → SizedSet
(A ⊗ B) i = A i × B i

c : Set → SizedSet
c A i = A
\end{code}

Timed types can be turned into types.
This corresponds to universal quantification in first order logic.
If we think of a time type as a predicate on times, 

\begin{code}
□ : SizedSet → Set
□ A = {i : Size} → A i
\end{code}

To see what is going on, let us look at an example of a timed type.

The natural numbers are generated by zero and the successor.
We can define these operations on the timed natural as well.
They are defined pointwise.


At every time, we have both zero and the successor of each timed natural number.
Other operations, for example the minimum, are defined in the same way.
Note that the function \AF{⊓} takes the minimum of two natural numbers.

The last combinator represents delayed computations.
For this, we need to look more closely to Agda's mechanism of sized types.
An important operation on sizes is the order and we use it to define an order on types.

The set \AF{Time<} \AB{i} represents the times smaller than \AB{i}.
With this order, we can now defined delayed computations.

\begin{code}
record ▻ (A : SizedSet) (i : Size) : Set where
  coinductive
  field force : (j : Size< i) → A j
open ▻ public
\end{code}

The only inhabitants \AF{▻} \AB{A} \AB{i} are those of \AB{A} \AB{j} for \AB{j} smaller than \AB{i}.
This means that something in \AB{A} \AB{i} is only accessible in \AF{▻} \AB{A} \AB{k} for \AB{k} greater than \AB{i}.
Or, in words, this means that inhabitants of \AB{A} are only available in \AF{▻} \AB{A} at later times.

Before discussing examples, let us first look at how to program with delayed computations.
First, we give \AF{▻} the structure of an applicative functor.

\begin{code}
pure : {A : SizedSet} → □ A → □(▻ A)
force (pure x) j = x

_⊛_ : {A B : SizedSet} → □(▻(A ⇒ B) ⇒ ▻ A ⇒ ▻ B)
force (f ⊛ x) j = force f j (force x j)
\end{code}

Secondly, we give a fixpoint combinator and here the order plays a crucial role.
The reason of that, is because it allows broader priductivity checks.
The semantics guarantee that there is no infinitely decreasing sequence of sizes.
In particular, if a size decrease in every recursive call of some function, then this map is productive.

\begin{code}
fix : {A : SizedSet} → □(▻ A ⇒ A) → □ A
▻fix : {A : SizedSet} → □(▻ A ⇒ A) → □ (▻ A)
fix f {i} = f (▻fix f {i})
force (▻fix f {i}) j = fix f {j}
\end{code}

We define the fixpoint of \AB{f} by repeatedly applying \AB{f}.
Since the argument of \AB{f} is delayed, we also need a delayed version of \AF{fix}, which we call \AF{▻fix}.
Note that this function calls \AF{fix} again, but the size decreases.
For that reason, this function is actually productive.

\begin{code}
equaion-h : □(▻(c ℕ) ⇒ ▻(c ℕ) ⊗ c ℕ) → □(▻(▻(c ℕ) ⊗ c ℕ) ⇒ ▻(c ℕ) ⊗ c ℕ)
equaion-h f x = f (pure proj₂ ⊛ x)

equation : □(▻(c ℕ) ⊗ c ℕ)
equation = fix (equaion-h (λ x → x , 1))

solution : ℕ × ℕ
solution = force (proj₁ equation) ∞ , proj₂ equation
\end{code}

\section{Eliminating Traversals}
Now we have developed sufficient material to formalize the program.
We start by defining the relevant data types: a data type of natural numbers and a data type of trees.
Remember that we already defined \AF{TimedNat} as a constant family.
The data type of trees is defined the same way.

\begin{code}
data Tree : Set where
  Leaf : ℕ → Tree
  Node : Tree → Tree → Tree
\end{code}

This data type has two constructors \AF{TLeaf} and \AF{TNode}.
We also have delayed versions of them.

\begin{code}
▻Leaf : □(▻(c ℕ) ⇒ ▻ (c Tree))
▻Leaf n = pure Leaf ⊛ n

▻Node : □(▻(c Tree) ⇒ ▻(c Tree) ⇒ ▻(c Tree))
▻Node t₁ t₂ = pure Node ⊛ t₁ ⊛ t₂
\end{code}

\begin{code}
fb-h : {T N : SizedSet} → □(▻ N ⇒ ▻ T ⊗ N) → □(▻(▻ T ⊗ N) ⇒ ▻ T ⊗ N)
fb-h f x = f (pure proj₂ ⊛ x)

feedback : {T N : SizedSet} → □(T ⊗ ▻ N ⇒ ▻ T ⊗ N) → □ T → □(▻ T ⊗ N)
feedback f t = fix (fb-h (λ n → f (t , n)))
\end{code}

Now we want to define the help function \AF{rmb}, which will be the argument for \AF{feedback}.
We take \AF{⊳ Tree} for \AB{B} and \AF{SizedNat} for \AB{U}.
Note that we must use \AF{⊳ Tree}, because otherwise we would not be able to apply \AIC{Node} or \AF{⊳Node}.

\begin{code}
rmb : □(c Tree ⊗ ▻(c ℕ) ⇒ (▻(c Tree)) ⊗ c ℕ)
rmb (Leaf x , n) = (▻Leaf n , x)
rmb (Node l r , n) =
  let (l' , ml) = rmb (l , n)
      (r' , mr) = rmb (r , n)
  in (▻Node l' r' , ml ⊓ mr)

replaceMin : Tree → Tree
replaceMin t = force (proj₁(feedback rmb t {∞})) ∞
\end{code}

\section{Proving with Sized Types}
Our next goal is to prove correctness.
Before doing that, we need to define timed predicates, timed relations, and combinators on them.

\begin{code}
TimedPredicate : SizedSet → Set₁
TimedPredicate A = {i : Size} → A i → Set

TimedRelation : SizedSet → SizedSet → Set₁
TimedRelation A B = {i : Size} → A i → B i → Set
\end{code}

Next we define universal quantification and for that we use dependent products.
Given a sized type \AB{A} and a predicate on \AB{A}, we get another sized type.

\begin{code}
all : (A : SizedSet) → TimedPredicate A → SizedSet
all A B i = (x : A i) → B x

syntax all A (λ x → B) = ∏[ x ∈ A ] B
\end{code}

Furthermore, for each sized type \AB{A}, we have a relation on \AB{A} representing equality.
For this we use propositional equality in Agda.

\begin{code}
eq : (A : SizedSet) → TimedRelation A A
eq A x y = x ≡ y

syntax eq A x y = x ≡[ A ]≡ y
\end{code}

\begin{code}
Size<Set : SizedSet
Size<Set i = Size< i
\end{code}


\section{Correctness}

\subsection{Specification}
\begin{code}
replace : Tree → ℕ → Tree
replace (Leaf x) n = Leaf n
replace (Node l r) n = Node (replace l n) (replace r n)

min-tree : Tree → ℕ
min-tree (Leaf x) = x
min-tree (Node l r) = min-tree l ⊓ min-tree r

replaceMin-spec : Tree → Tree
replaceMin-spec t = replace t (min-tree t)
\end{code}

\subsection{Proof}

\begin{code}
rmb₁ : □(∏[ p ∈ Size<Set ⊗ (c Tree ⊗ ▻(c ℕ)) ]
            let (j , t , n) = p in
            (force (proj₁ (rmb (t , n))) j ≡ replace t (force n j)))
rmb₁ (j , Leaf x , n) = refl
rmb₁ (j , Node l r , n) =
  begin
    force (▻Node (proj₁ (rmb (l , n))) (proj₁ (rmb (r , n)))) j
  ≡⟨ refl ⟩
    Node (force (proj₁ (rmb (l , n))) j) (force (proj₁ (rmb (r , n))) j)
  ≡⟨ cong (λ z → Node z _) (rmb₁ (j , l , n)) ⟩
    Node (replace l (force n j)) (force (proj₁ (rmb (r , n))) j)
  ≡⟨ cong (λ z → Node _ z) (rmb₁ (j , r , n)) ⟩
    Node (replace l (force n j)) (replace r (force n j))
  ∎

rmb₂ : □(∏[ p ∈ c Tree ⊗ ▻(c ℕ) ]
            let (t , n) = p in
            (proj₂ (rmb (t , n)) ≡[ c ℕ ]≡ min-tree t))
rmb₂ (Leaf x , n) = refl
rmb₂ (Node l r , n) =
  begin
    proj₂ (rmb (l , n)) ⊓ proj₂ (rmb (r , n))
  ≡⟨ cong (λ z → z ⊓ _) (rmb₂ (l , n)) ⟩
    min-tree l ⊓ proj₂ (rmb (r , n))
  ≡⟨ cong (λ z → _ ⊓ z) (rmb₂ (r , n)) ⟩
    min-tree l ⊓ min-tree r
  ∎

rm-correct : (t : Tree) → replaceMin t ≡ replaceMin-spec t
rm-correct t =
  begin
    replaceMin t
  ≡⟨ refl ⟩
    force (proj₁ (rmb (t , pure proj₂ ⊛ ▻fix (fb-h (λ x → rmb (t , x)))))) ∞
  ≡⟨ rmb₁ (∞ , t , pure proj₂ ⊛ ▻fix (fb-h (λ x → rmb (t , x)))) ⟩
    replace t (proj₂ (feedback rmb t))
  ≡⟨ cong (replace t) (rmb₂ (t , _)) ⟩
    replace t (min-tree t)
  ∎
\end{code}
